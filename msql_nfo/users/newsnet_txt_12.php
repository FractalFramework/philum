<?php 
return [1=>['testlong','Philum
Présentation

Historique

Le besoin de créer un CMS provient du constat selon lequel derrière chaque site web ce sont toujours les mêmes routines qui sont à l\'oeuvre.
Ainsi il apparaît qu\'un article est d\'abord un objet contenant des données stockées en mémoire, ensuite de quoi la façon de traiter es données détermine si on va faire un site de musique, de photos, un logiciel pour écrire un mémoire ou un site d\'actu.

Historique des Projets

- 1999 : Photonumerik
Galerie photo capable d\'afficher des miniatures en lisant un répertoire.

- 2000 : Musicnumerik
Ajout d\'un lecteur audio en flash, avec l\'idée de vendre les titres à l\'unité. 2001 : apparition de I-tunes.

- 2003 : FreeClonable
Idée d\'un CMS facile à installer à partir d\'une simple page de code, s\'inspirant du design du site prit en référence.

- 2004-2005 : WebTV
Ajout d\'une console d\'administration pour proposer une programmation, et des chaînes. Projet refusé pour cause de \"la vidéo sur internet ça ne marchera jamais\".
-- 2006 : apparition de Dailymotion et youtube

Plateforme de Dev

La création de sites pour des clients faisait en sorte d\'accumuler les fonctionnalités de façon à permettre aux clients suivants de bénéficier des travaux passés. Mais on a toujours besoin de quelque chose de nouveau.
De là apparaît un CMS ne suffit plus, nous avions surtout besoin d\'une plateforme de développement, qui utilise un langage et des protocoles classiques. Ainsi on peut appliquer n\'importe quel traitement aux données stockées.

C\'est à dire que le stockaqge des données et formalisé, et son traitement est semi-formalisé avec des protocoles.
Par exemple le protocole Ajax est une fonction qui reçoit 9 variables dont chacun a une signification précise, et qui convient à 99% des cas de figure qu\'on peut rencontrer. Il y en en a d\'autres comme les templates et les variables, et les connecteurs et les plugins.
En fait ce sont des dispositifs. C\'est pourquoi on peut parler de plateforme de Dev.

En passant, on a banni le \"site en travaux\" depuis longtemps, la dev peut se faire en ligne sans interférer avec ce que voit le visiteur.

La presse web

2006 : création de w41k.info, après avoir découvert une information complètement ignorée des médias (avec stupeur !).
Le Blogging qui consiste à générer des articles d\'opinion s\'accompagne d\'un over-blogging qui consiste en une néguentropie, l\'organisation des contenus dans le cadre d\'un thème. En fait tous les journaux possèdent une identité qui prédéfini les articles qu\'il va choisir. De là apparaît l\'importance du classement, et la réalisation du rêve de l\'\'internet : pouvoir naviguer d\'un article à l\'autre autour d\'un même sujet. C\'est la classification qui permet de croiser les infos.

Un site d\'info est indifférent à l\'esprit du site et même au contenu, il ne s\'intéresse qu\'à la façon dont les données peuvent être croisées.
C\'est pourquoi on a la liberté de publier des articles qui vont contre l\'esprit du site, étant donné que leur signification est générée par ce à quoi cet article est lié.

Autant dire tout de suite que quand un politicien dit \"tout va bien\", il est automatiquement classé dans la catégorie gags, lol, hypo-crise...

Ainsi le site d\'actu est capable de suivre les virages de l\'histoire (qui se joue devant nos yeux), là où un journal en papier ne s\'autorise pas à parler d\'Ovnis ou d\'expériences sociales anti-système, parce que ça sort de son cadre.

Cela a donné l\'idée de faire en sorte que les catégories soient virtuelles, juste une émergence des articles, et non pas une liste de catégories existantes à remplir. Si aucun article ne sort dans une catégorie, elle disparaît de la liste des menus.

Cela a aussi permit de créer le Time-System, qui permet à l\'utilisateur de choisir la périodicité du site selon ses visites (quotidien, hebdo, mensuel) et dans ce cas il accès à un nombre à peu près équivalent d\'articles pour chaque période (selon la priorité de l\'article).

La plongée dans la complexité

Le site est devenu de plus en plus complexe mais en même temps de plus en plus performant, rapide et simple à comprendre.
Ce n\'est pas contradictoire c\'est logique.

En fait la complexité rime avec l\'efficacité. Si on se figure une pyramide, la quantité d\'actions à faire pour une tâche se positionne entre la plateforme de Dev en bas, et l\'activation vocale tout en haut, pour une même tâche. C\'est la complexité qui permet d\'obtenir la puissance avec un simple bouton. Et son absence oblige à s\'empêtrer dans l\'incompréhension.

C\'est l\'automatisation qui est responsable de cela, c\'est à dire qu\'à force de répliquer les mêmes tâches on finit par les automatiser.
Ainsi apparaît le terme de productivité (l\'ennemi du système). On peut prévoir par exemple que la productivité tend naturellement vers un rapport de plus en plus élevé entre le nombre de personnes qui travaillent et le nombre de personnes qui profitent de ce travail.

En effet les routines tendent à s\'agglutiner en interfaces utilisateur, de même que les fonctions PHP tendent à s\'agglutiner en éléments d\'un langage.

Le rapport aux utilisateurs

L\'ordinateur du Diable

L\'ennemi du programmeur est l\'utilisateur car il ne manifeste aucune affectivité pour son outil, et l\'utilisation qu\'il en fait est parfois si absurde qu\'on le croirait mal intentionné.

Et en même temps cette confrontation entre le créatif et l\'utilisateur est une source d\'inspiration. Elle est indispensable pour le développement du logiciel.
En particulier je veille à toujours rester un utilisateur intensif du logiciel ; ce n\'est pas possible d\'émettre des fonctionnalités sans en avoir eu besoin.

L\'aller-retour entre théorie et pratique

En plus du retour des utilisateurs il faut veiller à ce qu\'ils ne disent pas, et pour se mettre à leur place il faut adopter un état d\'esprit très critique vis à vis de son travail, ce qui n\'est possible qu\'avec un peu de recul. (parce que après la prog on est fatigués)

Ainsi le façonnement du logiciel est le produit d\'une confrontation continuelle entre la créativité et un utilisateur imaginaire qui serait impatient et avec un esprit confus.

Mais l\'utilisateur aussi doit faire un pas vers le logiciel, en acceptant d\'apprendre des procédures qui paraissent simples quand on les connaît, et qu\'il peut expliquer à son tour.

Au final quand l\'utilisateur s\'approprie un outil, il tisse avec lui des liens affectifs à condition que les protocoles qu\'on lui demande de connaître soient acceptables. (la plupart du temps l\'utilisateur n\'accepte rien... mais dans ce cas il n\'obtient rien non plus)

La programmatique

On peut trouver beaucoup de tentatives de rendre accessible l\'écriture de code à l\'utilisateur.
Et le HTML n\'est pas acceptable, car il permet les erreurs ou la malveillance, en plus d\'être laborieux. On se limite en général à l\'usage de symboles qui sont interprétés pour produire du code (Spip). Aucun n\'est satisfaisant ni non plus facile à mémoriser.

De plus il va devenir question de permettre à l\'utilisateur de créer des applications, et pas seulement de paramétrer des modules existants.
De même il peut avoir à composer des templates pour produire des données branchées sur une base de données (ne serait-ce que pour composer des étiquettes, par exemple).
(on a un plugin pour faire des cartes de visites)

Ce n\'est pas tant de la programmation que de la bureautique, donc on l\'appelle la programmatique, l\'art qui consiste à pemettre des résultats imprévisibles quoi que suffisemment contrôlés pour éviter la malveillance, ou même mieux, guider l\'utilisateur quand il commet des erreurs.

Les connecteurs

Beaucoup de fois j\'entends \"pourquoi réinventer la roue\" à propos des connecteurs dont le but est de remplacer le Html, y compris dans la base de données.
(ce ne sont pas les inventeurs de roue qui tiennent ce discours)

1 - Premièrement ça occasionne un gain de 30% de poids par rapport au Html, en plus de produire un code Html \"propre\" c\'est à dire sans redondances.
2 - Ensuite c\'est facile à comprendre et à mémoriser : pour convertir une balise blockquote en bold, il suffit de...

[texte:q]
[texte:b]

changer une lettre.

3 - Quand le Html évolue, la balise
[texte:i]
italique qui renvoyait
<i>texte</i>
il suffit d\'un seul changement dans le programme pour que toutes les occurrences renvoient :
<em>texte</em>

De même ça permet d\'exporter notre texte pour n\'importe quel type de rendu, comme par exemple les e-books.

Les connecteurs interprètent le code comme les balises, en suivant le  double déroulement : imbrication-succession.
L\'interpréteur prend :

function format_txt_r($msg,$media,$id){
$in=strpos($msg,\"[\");
if($in!==false){
    $deb=substr($msg,0,$in);
    $out=strpos(substr($msg,$in+1),\"]\");
    if($out!==false){
        $msb=substr($msg,$in+1,$out);
        $nb_in=substr_count($msb,\"[\");
        if($nb_in>=1){
            for($i=1;$i<=$nb_in;$i++){$out_tmp=$in+1+$out+1;
                $out+=strpos(substr($msg,$out_tmp),\"]\")+1;
                $nb_in=substr_count(substr($msg,$in+1,$out),\"[\");}
            $mid=substr($msg,$in+1,$out);
            $mid=format_txt_r($mid,$media,$id);}
        else $mid=$msb;
        $mid=connectors($mid,$media,$id);
        $end=substr($msg,$in+1+$out+1);
        $end=format_txt_r($end,$media,$id);}
    else $end=substr($msg,$in+1);}
else $end=$msg;
return $deb.$mid.$end;}

21 lignes de code.

Les templates

Les templates sont seulement responsables de la mise en forme des modules.
La mise en forme du site, elle, n\'est pas confiée à des templates mais à des procédures classiques et inflexibles : des blocs de modules qui sont autant de balises DIV dans la page, qui sont mises en page par les Css.

C\'est le même langage que les connecteurs mais c\'est une routine indépendant et bien plus rapide, qui n\'est responsable que des balises Html et de leurs attributs. Le but du jeu est de placer des variables _VAR dans ces connecteurs de mise en forme.

Le design

Le constructeur de Css permet de différencier les jeux de couleurs du design, dans lequel il y a des références aux couleurs sous forme de variables #_1.

C\'est une décision politique que de ne pas avoir des centaines de designs disponibles car ils sont si facile à créer et modifier qu\'il vaut largement mieux appliquer simplement un jeu de couleur personnalisé à un design existant pour obtenir quelque chose de nouveau.
Le design par défaut est souvent réactualisé et l\'utilisateur peut recevoir ces nouvelles définitions. On peut prévoir de faire un système d\'abonnement à des designs.

Le Codeline

De façon expérimentale on a poussé le principe au Codeline, qui sont des connecteurs imbriquables sans les crochets, où chaque ligne de code renvoie un résultat qui peut être traité par les lignes suivantes.
Le Codeline donne accès au noyau du logiciel et à ses 300 fonctions de base.
ça se lit de droite à gauche et ça ressemble à peu près à cela :

texte:b:i:u /// texte bold italic souligné
//on affecte la miniature d\'une image à une variable
_1=image.jpg:thumb

//_1:div + attribut float:left:style
//on place l\'image dans une Div avec l\'attribut classe=\"css\"
_1|float:left:style:div //

En pratique ça permet seulement d\'ajouter des mentions automatiques dans les articles, ou de créer un système qui renvoie une image choisie aléatoirement par exemple.

Les modules

Les modules sont des connecteurs plus élaborés, écrits en PHP, qui font appel aux ressources du noyau ou à des plugins.
Les modules accèdent aux connecteurs qui accèdent au codeline,
autant il est possible d\'appeler un module depuis un connecteur nommé \':module\'.

Les bases de données solides ou MicroSql, ou Msql

Il était hérétique de vouloir confier l\'intégralité des appels de données à MySql. Les calculs ont montré qu\'en dessous d\'une centaine de Kilo-octets, il est
- 3 fois plus rapide de faire un fopen()
- 6 fois plus rapide de faire un require().

Il a fallu innover car aucune solution ne se passait du fopen().
On a donc décidé de créer un gestionnaire qui enregistre les données directement dans des pages PHP qu\'ensuite il n\'y a plus qu\'à require().

function msql_read_a($dir,$nod){$f=$dir.$nod.\'.php\';
if(is_file($f)){require($f); return $r?$r:$$nod;}}

Au début il s\'agissait simplement d\'avoir des tableaux relatifs aux fichiers existants pour les galeries d\'images et de musiques, pour éviter d\'avoir à parcourir le disque, tout en ayant l\'avantage de contrôler comment elles sont ordonnées et d\'y adjoindre du texte.

Puis ça a été le tour des éléments de langue du logiciel et des aides contextuelles. Et enfin c\'est devenu les support de la couche la plus élevée du logiciel, celle qui évolue vite, quand on a besoin de rajouter des fonctionnalités sans avoir à toucher au code, tels que les modules et les connecteurs.
Et étant donné que le cache des articles est aussi confié à Msql, il ne reste plus que le corps des articles qui soit confié à MySql, car il peut facilement dépasser les 100Ko, ainsi que les mots de passe, et les commentaires.

Au final il s\'agit de tirer le meilleur parti de chaque technologie. Car la plus grande contrainte des systèmes web est la rapidité de génération des pages.
Ainsi, dans 90% des appels d\'une pages, se sont seulement 300 Ko de code qui ont besoin d\'être chargés, environ 50Ko Ko de données Msql provenant d\'une dizaine de tables, ainsi que le contenu de l\'article. Il y a environ 6 requêtes Mysql par page affichée, même si des centaines d\'articles sont présentés sur la page. Le temps d\'exécution sur le serveur le plus minable de la terre excède rarement une demi seconde.

Et enfin ça permet de donner à l\'utilisateur la possibilité d\'utiliser des bases de données pour son usage personnel, qui peuvent être affichées dans ses articles de diverses manières, et partager d\'un serveur à l\'autre. Y compris le design et la config du site peuvent être partagés.

Tour rapide des fonctionnalités

La gestion de contenu

L\'édition des articles se fait sur place et les effets sont immédiats.
L\'importation d\'un article existant est quasiment entièrement automatisée.

Le classement

On peut créer des classes de tags utilisateur comme \"thèmes\", \"auteurs\", \"pays\"... La catégorie de l\'article est finalement aussi un \"méta\".
Les articles peuvent être liés topologiquement les uns aux autres et générer une taxonomie qui peut très bien convenir, par exemple, à un site de généalogie. (ou de taxonomie des animaux)

Le déploiement

C\'est très important de comprendre que les données sur le site, qui sont assemblées par le logiciel, sont faites pour être distribuées à des utilisateurs ou à des serveurs qui envoient des requêtes, en suivant un protocole.

Pour ça on a décidé que la barre d\'adresse était en fait une console Url qui permet d\'interroger le site avec en utilisant une ligne de commande.

On peut obtenir des données brutes via le protocole MicroXml qui est capable de faire voyager des données tabulaires, et qui est utilisé pour transporter des tables Msql d\'un serveur à l\'autre, notamment celles qui concernent les fichiers partagés.

L\'évolution

Le façonnement du logiciel

Beaucoup d\'idées sont apparues simplement en faisant la jonction entre des fonctions existantes. Et inversement les nouvelles idées conditionnent d\'une nouvelle manière la façon d\'écrire les fonctions existantes.

Les perspectives

A terme on s\'imagine que l\'Open Data ne peut pas exister sans un protocole systématique, car il ne peut être question d\'avoir à suivre des procédures locales à chaque fois qu\'on a besoin de données publiques.

Le Desktop

L\'aboutissement de la recherche de simplification a donné naissance au Desktop. Ce n\'est plus un site avec des pages qu\'on a devant les yeux mais l\'interface d\'un système d\'exploitation, avec des données et des logiciels.
Là où c\'est vraiment excitant c\'est de s\'imaginer par quoi remplacer Google dans la page d\'accueil : par un Desktop,
un espace de travail qui reçoit des flux de données publiques, affichées avec des applications qui sont libres.
On essaie autant que possible de n\'avoir qu\'une appli par fonction, toujours la meilleure, et facile à faire évoluer, mais ça n\'empêche pas la multitude.

Le Desktop qui sera proposé pour remplacer Google devra dissimuler, sans en faire la pub, toute une architecture logicielle mûrement réfléchie et longtemps testée pour ensuite pouvoir imposer les protocoles dont le web a besoin, tant au niveau de l\'écriture programmatique que des protocole de l\'Open Data.1']]; ?>