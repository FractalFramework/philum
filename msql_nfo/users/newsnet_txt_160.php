<?php 
return [1=>['bonnes pratiques','Je suis obligé d\'inventer des noms mais bon : 

- Principe de conception Solid-Acid (lisible, logique, isolé, durable)
- Architecture : récursive-successive (clean architecture réemployable)
- Structure logicielle : pseudo-neurale (séparation des métiers à outrance, hiérarchies logiques)
- Paradigme de prog : semi-conducteur (Poo statique et couches abstraites)
- Style de code : smart vars (usage des types au lieu des noms) <= eh oui
- Base de donnée des paramètres : dB (admin de variables du code)

Bonnes pratiques :
- aucun \"echo\" dans le code
- aucun contenu dans le code
- aucun html dans le code
- aucun request (get/post) dans le code
- aucun mot de passe dans le code
- aucune visibilité des erreurs
- aucune décision subjective dans le code (sauf choses indubitables)
- minimisation des conditions
- minimisation des transports
- minimiser la redondance
- minimisation des filtres sans nom (tout traitement doit être classique)
- maximisation des procédures habituelles (compatibilité des types de tableaux)
- modularité fractale du code : des grands groupes et des sous groupes sont déconnectables et remplaçables
- politique de nommage décisionnelle
- typage des variables et des fonctions
- MVC->MAC : modèles mathématiques + assembleurs + constructeurs (dont templateurs)
- moteurs logiciels (moteur Mysql, moteur Ajax, moteur de templates)
- priorisation structurelle (plus on structure le code, plus on le soulage = difficile à lire mais plus rapide à exécuter, vaut mieux que facile à lire et long à exécuter)
- penser le problème en amont (permet de réduire la complexité)
- simplifier les problèmes
- penser réemployabilité : toute fonction a pour but de servir le plus possible
- penser algorithmie : plus on mathématise, plus le code est succinct et puissant
- penser concepts : il faut pouvoir nommer ce qui est fait, et définir ses principes
- penser dispositifs : toute action verbalisable doit être objective dans le code
- penser Légo : les dispositifs doivent pouvoir s\'emboiter (compatibilité de la législation logicielle)
- penser échafaudage : toute évolution laisse des traces qui peuvent être réactivables en cas de défaite d\'un système moderne
- penser déclinaison : une fonction simple pour 80% des cas et une ou plusieurs répliques spécialisées pour les autres
- penser itération : \"l\'itération est ton amie\"
- penser automatisme : maximiser les processus existants, mais savoir aussi s\'en passer
- penser rollback : toute modif est sauvegardée en local sans faire appel à Git
- aucun commentaire de code : il se suffit à lui-même si on connaît l\'architecture, sauf pour les déclinaisons, aides à la compréhension, nommages de groupes, et options stratégiques
- penser dev : tout ou partie est testable, réparable dans la minute, ou mutable vers une autre solution.
- penser entonnoir : les ganglions sont là pour concentrer les flux et centraliser les process
- penser vitesse, tout le temps, dans tout, pour tout (RAM, SDD, processeur, rendu, énergie)
- repenser l\'existant en permanence, être prêt à tout refaire :)
- penser à s\'arrêter quand on commence à faire trop d\'erreurs :)

']]; ?>